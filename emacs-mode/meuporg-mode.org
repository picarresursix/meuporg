#+TITLE: Meuporg-mode
#+DESCRIPTION: The litterate code of the meuporg-mode.
#+AUTHOR: LÃ©o Perrin <leoperrin@picarresursix.fr>
#+DATE: Time-stamp: <2013-01-20 15:07:05 leo>
#+STARTUP: hidestars indent



* Introduction
  Meuporg supports two file format for the main file, markdown and
  org. However, org is the one to prefer to leverage all of its power:
  it was intended to be used with emacs.

  Therefore, a minor-mode providing hopefully useful shortcuts is
  provided. It gives functions allowing to:
    + Easily insert items often used items.
    + Fontify them
    + Update a main file.
    + Go to the main file of which a files depends.

** This file
This is literate programming using org-babel, so open this file with
emacs. To edit a snippet of code, use /C-c '/ to open a new frame in
the correct mode and /C-c '/ again to close it. To create the source
file (an operation called "tangling"), use /C-c C-v f/.

* The meuporg command
Meuporg is not a "real" executable somewhere in the $PATH so we must
tell emacs the command to run to use it.
#+begin_src lisp :tangle meuporg.el
  (setq meuporg-command "python ~/.meuporg ")
#+end_src
* Update main fileU
    This function is very straightforward: we run the shell command
    "meuporg -u" after saving the current buffer.
    #+begin_src lisp :tangle meuporg.el
      (defun meuporg-reload()
        "Reload the current meuporg."
        (interactive)
        (save-buffer)
        (shell-command (concat meuporg-command " -u"))
        )
    #+end_src
* Opening the main file
** meuporg-find-main
    This function goes up in the directory tree until it finds a
    meuporg.org file in one of the parent directories. Then, it
    returns the path to the said file or an empty string if it didn't
    find any.

    Actually, we just use the output of "meuporg -f" but, to retrieve
    it, we need to get the content of the "*Shell Command Output*"
    buffer (and remove the last character, a new line). Then, we move
    back to the buffer where we were and, to be able to do so, we
    first store the said buffer in a variable.
    #+begin_src lisp :tangle meuporg.el
      (defun meuporg-find-main()
        "Returns the path to meuporg of which the current file depends or an
      empty string if there is no such meuporg."
        (setq old-buffer (current-buffer))
        (shell-command (concat meuporg-command " -f"))
        (switch-to-buffer "*Shell Command Output*")
        (setq path-to-main-meuporg
              (buffer-substring-no-properties (point-min) (- (point-max) 1))
              )
        (switch-to-buffer old-buffer)
        path-to-main-meuporg
        )
    #+end_src
** meuporg-open-main
    Opens the main file of which the current file depends using the
    output of meuporg-find-main. If there is no such buffer, does
    nothing.
    #+begin_src lisp :tangle meuporg.el
      (defun meuporg-open-main()
        "Open the meuporg of which the current file depends (if any)."
        (interactive)
        (setq path-to-main-meuporg (meuporg-find-main))
        (if (< 2 (length path-to-main-meuporg))
            (progn
              (find-file path-to-main-meuporg)
              (message (concat "Opening " path-to-main-meuporg))
              )
            (message "No meuporg found.")
            )
        )
    #+end_src
* Interacting with items in a file
   Items live in "regular" file, i.e. those I actually work with: .c,
   .cpp, .tex, .py, etc. Thus, I want to interact with items all the
   time: inserting them and locating them easily.
** meuporg-insert-item
    We want common items to be easy to insert, so we create smalls
    functions to quickly put any item where the cursor is. Nothing
    fancy, it just an interactive call to "insert".
    #+begin_src lisp :tangle meuporg.el
      (defun meuporg-insert-todo()
        "Inserts a TODO meuporg item."
        (interactive)
        (insert "!TODO! ")
        )

      (defun meuporg-insert-idea()
        "Inserts an IDEA meuporg item."
        (interactive)
        (insert "!IDEA! ")
        )

      (defun meuporg-insert-tocheck()
        "Inserts a TOCHECK meuporg item."
        (interactive)
        (insert "!TOCHECK! ")
        )

      (defun meuporg-insert-fixref()
        "Inserts a FIXREF meuporg item."
        (interactive)
        (insert "!FIXREF! ")
        )
    #+end_src
** meuporg-go-to-next-item
    If there is another item further in the file, moves the cursor to
    it (see [[http://curiousprogrammer.wordpress.com/2009/06/08/error-handling-in-emacs-lisp/][this blog post]] for info about error handling).
    #+begin_src lisp :tangle meuporg.el
      (defun meuporg-go-to-next-item()
        (interactive)
        (condition-case ex
            (search-forward-regexp "\![a-zA-Z0-9_]*\!")
          ('error
           (message "No items after cursor.")
           )
          )
        )
    #+end_src
** meuporg-go-to-previous-item
    The same as before, but for what is before in the file.
    #+begin_src lisp :tangle meuporg.el
      (defun meuporg-go-to-previous-item()
        (interactive)
        (condition-case ex
            (search-backward-regexp "\![a-zA-Z0-9_]*\!")
          ('error
           (message "No items before cursor.")
           )
          )
        )
    #+end_src
** meuporg-toggle-item-highlighting
Use [[http://www.gnu.org/software/emacs/manual/html_node/emacs/Highlight-Interactively.html][hi-lock-mode]].
* List and jump to items in a file
The search of items in a file and the navigation among them relies on
the `occur` elisp function. The idea is to use occur to find all lines
cotaining an item and to tweak the occur buffer a bit to make it more
convenient in this context.

Modifications to the regular occur buffer are the following.
+ addition of local keymap: up moves up (respectively down) an item in
  the list.
+ when an item is selected, moving the cursor up or down the list
  makes the buffer containing the file move as well so as to have
  current item at the center of the window.
** move from items to items in item list
When go up (or down) an item in the list, we want the other file to go
to it (which is achieved using occur-mode-goto-occurrence) and then
come back to the occur buffer.
#+begin_src lisp :tangle meuporg.el
  (defun meuporg-list-next-item()
    "Move to the next item in the meuporg list"
    (interactive)
    (if (string= (buffer-name) "!List!")
        (progn
          (occur-next)
          (occur-mode-goto-occurrence)
          (recenter)
          (other-window 1)
        )
      )
    )
  
  (defun meuporg-list-previous-item()
    "Move to the previous item in the meuporg list"
    (interactive)
    (if (string= (buffer-name) "!List!")
        (progn
          (occur-prev)
          (occur-mode-goto-occurrence)
          (recenter)
          (other-window 1)
        )
      )
    )
  
#+end_src
** meuporg-list-items-in-file
This functions call occur with the correct pattern to look for items
in the current file, rename it "!List!" (after killing any other
buffer having this name), turn on the meuporg-list minor-mode and
moves the cursor to the list. It also highlights the lines containing
the items in the file.
#+begin_src lisp :tangle meuporg.el
  (defun meuporg-list-items-in-file()
    (setq meuporg-listed-buffer (current-buffer))
    (interactive)
    (meuporg-kill-item-list)
    (delete-other-windows)
    (occur "![A-Za-z0-9_]+!")
    (switch-to-buffer "*Occur*")
    (rename-buffer "!List!")
    (meuporg-list-mode)
    (occur-next)
    (switch-to-buffer meuporg-listed-buffer)
    (highlight-lines-matching-regexp "![A-Za-z0-9_]+!")
    (other-window 1)
    (next-line)
    )
#+end_src
** meuporg-kill-item-list
This functions removes the highlighting of the items and kills the
buffer containing the item list.
#+begin_src lisp :tangle meuporg.el
  (defun meuporg-kill-item-list()
    "Kills the buffer containing the item list and turns off line
  highlighting."
    (interactive)
    (switch-to-buffer meuporg-listed-buffer)
    (hi-lock-mode -1)
    (if (get-buffer "!List!")
        (progn
          (switch-to-buffer "!List!")
          (quit-window t)
          )
      )
    (delete-other-windows)
    )
#+end_src

** meuporg-list-mode
This minor-mode provides convenient key-bindings for the list of items
generated with occur.
#+begin_src lisp :tangle meuporg.el
  (define-minor-mode meuporg-list-mode
      "Toggle meuporg-list mode.
  
    Interactively with no argument, this command toggles the mode.
    A positive prefix argument enables the mode, any other prefix
    argument disables it.  From Lisp, argument omitted or nil enables
    the mode, `toggle' toggles the state. "
     ;; The initial value.
     :init-value nil
     ;; The indicator for the mode line.
     :lighter " !L!"
     :keymap
     `(
       (,(kbd "<down>")   . meuporg-list-next-item)
       (,(kbd "<up>")     . meuporg-list-previous-item)
       )
     )
   #+end_src

* meuporg-mode
** minor-mode declaration
   We want to define a minor-mode granting access to the keybindings
   and the fontifying of known items. To do so, we apply what is
   suggested [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Defining-Minor-Modes.html#Defining-Minor-Modes][here]]. The keymap had to employ a backquote and commas,
   take a look at [[http://stackoverflow.com/questions/3115104/how-to-create-keybindings-for-a-custom-minor-mode-in-emacs][stackoverflow]] to see why.

   In order to be able to use the key "C-!" as the prefix, we first
   had to undefine this key.
   #+begin_src lisp :tangle meuporg.el
     (global-unset-key (kbd "C-!"))
     
     (define-minor-mode meuporg-mode
         "Toggle meuporg mode.
     
       Interactively with no argument, this command toggles the mode.
       A positive prefix argument enables the mode, any other prefix
       argument disables it.  From Lisp, argument omitted or nil enables
       the mode, `toggle' toggles the state. "
        ;; The initial value.
        :init-value nil
        ;; The indicator for the mode line.
        :lighter " !M!"
        :keymap
        `(
          (,(kbd "C-! u")   . meuporg-reload)
          (,(kbd "C-! m")   . meuporg-open-main)
          (,(kbd "C-! n")   . meuporg-go-to-next-item)
          (,(kbd "C-! p")   . meuporg-go-to-previous-item)
          (,(kbd "C-! l")   . meuporg-list-items-in-file)
          (,(kbd "C-! q")   . meuporg-kill-item-list)
          (,(kbd "C-! i t") . meuporg-insert-todo)
          (,(kbd "C-! i i") . meuporg-insert-idea)
          (,(kbd "C-! i c") . meuporg-insert-tocheck)
          (,(kbd "C-! i f") . meuporg-insert-fixref)
          )
        )
   #+end_src

** Fontifying
   Now that we have a minor-mode, we add fontifying for the
   items. Items are strings containing non-space character enclosed
   between exclamation marks, so we look for this pattern.
   #+begin_src lisp :tangle meuporg.el
     (add-hook 'meuporg-mode-hook
              (lambda ()
                (font-lock-add-keywords nil '(("!\\([a-zA-Z0-9_]*\\)!" 1 font-lock-warning-face t)))
                )
              )
   #+end_src

** Adding a hook to turn on the mode
    We want the meuporg minor-mode to be switched on whenever a file
    is on the directory tree below a meuporg. To do so, we check that
    the output of meuporg-find-main has a greater than 1 length.
    #+begin_src lisp :tangle meuporg.el
      (add-hook 'find-file-hook
                (lambda()
                  (if (< 1 (length (meuporg-find-main)))
                      (meuporg-mode)
                    )
                  )
                )
    #+end_src
